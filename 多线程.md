Thread类  Runnable接口  

停止线程：不能用stop(),设置使用退出标记  
互斥：同一时间只能有一条线程对关键区域或临界数据进行操作synchronized  
同步：线程之间的一种通信机制wait()notify()notifyAll()  
wait()：将当前线程放入Wait Set，并释放锁。  
notify()：从Wait Set中唤醒某一线程，进入竞争队列。  
notifyAll()：唤醒Wait Set中的所有线程，进入竞争队列。  
  
## Thread和Runnable  

* Runnable方式可以避免Thread方式由于Java单继承特性带来的缺陷
* Runnable的代码可以被多个线程(Thread实例)共享,适合于多个线程处理同一资源的情况
  
守护线程：一般运行于后台，为其它的用户线程来服务，当所有的用户线程都消亡，没有可服务的对象，守护线程即会自动消亡。例如检测服务，常见例子如JAVA的垃圾回收机制。所有在守护线程里面不适合做计算以及业务逻辑的操作  
创建方式:在线程启动之前调用setDaemon(threadName,true)来申明这个是守护线程即可  

## 可见性  
可见性：一个线程对共享变量值的修改，能及时的被其他线程看到。  
共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量  
Java内存模型(JMM)：描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节  

![Alt text](/image/thread1.png "内存模型")  

* 所有变量都存储在主内存中
* 每个线程都有自己独立的工作内存，里面保存了该线程使用到的变量的副本(主内存中该变量的一份拷贝)
* 线程对共享变量的操作都必须在自己的工作内存中进行，不能直接从主内存读取
* 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成  

共享变量可见性实现的原理  
![Alt text](/image/thread2.png "可见性实现")   

#### synchronized实现可见性  
  
JMM关于synchronized的两条规定：  

* 线程解锁前,必须把共享变量的最新值刷新到主内存中
* 线程加锁时,将清空工作内存中共享变量的值,从而使用共享变量时需要从主内存中重新读取最新的值(注意:加锁与解锁需要是同一把锁)  

线程执行互斥代码的过程：

1. 获得互斥锁
2. 清空工作内存
3. 从主内存拷贝变量的最新副本到工作内存
4. 执行代码
5. 将更改后的共享变量的值刷新到主内存
6. 释放互斥锁

重排序：代码书写的顺序和实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而作的优化  

1. 编译器优化的重排序(编译器优化)
2. 指令集并行重排序(处理器优化)
3. 内存系统的重排序(处理器优化)

as-if-serial：无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致(java在单线程下遵循as-if-serial语义)  
  
导致共享变量在线程间不可见的原因：  

1. 线程的交叉执行
2. 重排序
3. 共享变量更新后没有及时在工作内存与主内存及时更新


#### volatile实现可见性

线程写volatile变量的过程：

1. 改变线程工作内存中volatile变量副本的值
2. 将改变后的副本的值从工作内存刷新到主内存中

线程都volatile变量的过程：

1. 从主内存中读取volatile变量的最新值到工作内存中
2. 从工作内存中读取volatile变量副本

volatile不保证原子性  
volatile不会阻塞